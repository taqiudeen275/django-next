import { ZodType } from 'zod';
import { createParamOrRef } from './parameters';
import { createRequestBody } from './paths';
import { createHeaderOrRef, createResponse } from './responses';
import { createSchemaOrRef } from './schema';
export const getDefaultComponents = (componentsObject, openapi = '3.1.0') => {
    const defaultComponents = {
        schemas: new Map(),
        parameters: new Map(),
        headers: new Map(),
        requestBodies: new Map(),
        responses: new Map(),
        openapi,
    };
    if (!componentsObject) {
        return defaultComponents;
    }
    createSchemas(componentsObject.schemas, defaultComponents);
    createParameters(componentsObject.requestParams, defaultComponents);
    createRequestBodies(componentsObject.requestBodies, defaultComponents);
    createHeaders(componentsObject.responseHeaders, defaultComponents);
    createResponses(componentsObject.responses, defaultComponents);
    return defaultComponents;
};
const createSchemas = (schemas, components) => {
    if (!schemas) {
        return;
    }
    Object.entries(schemas).forEach(([key, schema]) => {
        if (schema instanceof ZodType) {
            if (components.schemas.has(schema)) {
                throw new Error(`Schema ${JSON.stringify(schema._def)} is already registered`);
            }
            const ref = schema._def.openapi?.ref ?? key;
            components.schemas.set(schema, {
                type: 'partial',
                ref,
            });
        }
    });
    return Array.from(components.schemas).forEach(([schema, { type }]) => {
        if (type === 'partial') {
            const state = {
                components,
                type: schema._def.openapi?.refType ?? 'output',
            };
            createSchemaOrRef(schema, state);
        }
    });
};
const createParameters = (requestParams, components) => {
    if (!requestParams) {
        return;
    }
    Object.entries(requestParams).forEach(([paramType, zodObject]) => {
        Object.entries(zodObject._def.shape()).forEach(([key, schema]) => {
            if (schema instanceof ZodType) {
                if (components.parameters.has(schema)) {
                    throw new Error(`Parameter ${JSON.stringify(schema._def)} is already registered`);
                }
                const ref = schema._def.openapi?.param?.ref ?? key;
                components.parameters.set(schema, {
                    type: 'partial',
                    ref,
                    in: paramType,
                });
            }
        });
    });
    return Array.from(components.parameters).forEach(([schema, component]) => {
        if (component.type === 'partial') {
            createParamOrRef(schema, component.in, component.ref, components);
        }
    });
};
const createHeaders = (responseHeaders, components) => {
    if (!responseHeaders) {
        return;
    }
    Object.entries(responseHeaders._def.shape()).forEach(([key, schema]) => {
        if (components.parameters.has(schema)) {
            throw new Error(`Header ${JSON.stringify(schema._def)} is already registered`);
        }
        const ref = schema._def.openapi?.param?.ref ?? key;
        components.headers.set(schema, {
            type: 'partial',
            ref,
        });
    });
    return Array.from(components.headers).forEach(([schema, component]) => {
        if (component.type === 'partial') {
            createHeaderOrRef(schema, components);
        }
    });
};
const createResponses = (responses, components) => {
    if (!responses) {
        return;
    }
    Object.entries(responses).forEach(([key, responseObject]) => {
        if (components.responses.has(responseObject)) {
            throw new Error(`Header ${JSON.stringify(responseObject)} is already registered`);
        }
        const ref = responseObject?.ref ?? key;
        components.responses.set(responseObject, {
            type: 'partial',
            ref,
        });
    });
    return Array.from(components.responses).forEach(([schema, component]) => {
        if (component.type === 'partial') {
            createResponse(schema, components);
        }
    });
};
const createRequestBodies = (requestBodies, components) => {
    if (!requestBodies) {
        return;
    }
    Object.entries(requestBodies).forEach(([key, requestBody]) => {
        if (components.requestBodies.has(requestBody)) {
            throw new Error(`Header ${JSON.stringify(requestBody)} is already registered`);
        }
        const ref = requestBody?.ref ?? key;
        components.requestBodies.set(requestBody, {
            type: 'partial',
            ref,
        });
    });
    return Array.from(components.requestBodies).forEach(([schema, component]) => {
        if (component.type === 'partial') {
            createRequestBody(schema, components);
        }
    });
};
export const createComponentSchemaRef = (schemaRef) => `#/components/schemas/${schemaRef}`;
export const createComponentResponseRef = (responseRef) => `#/components/responses/${responseRef}`;
export const createComponentRequestBodyRef = (requestBodyRef) => `#/components/requestBodies/${requestBodyRef}`;
export const createComponents = (componentsObject, components) => {
    const combinedSchemas = createSchemaComponents(componentsObject, components.schemas);
    const combinedParameters = createParamComponents(componentsObject, components.parameters);
    const combinedHeaders = createHeaderComponents(componentsObject, components.headers);
    const combinedResponses = createResponseComponents(components.responses);
    const combinedRequestBodies = createRequestBodiesComponents(components.requestBodies);
    const { schemas, parameters, headers, responses, requestBodies, ...rest } = componentsObject;
    const finalComponents = {
        ...rest,
        ...(combinedSchemas && { schemas: combinedSchemas }),
        ...(combinedParameters && { parameters: combinedParameters }),
        ...(combinedRequestBodies && { requestBodies: combinedRequestBodies }),
        ...(combinedHeaders && { headers: combinedHeaders }),
        ...(combinedResponses && { responses: combinedResponses }),
    };
    return Object.keys(finalComponents).length ? finalComponents : undefined;
};
const createSchemaComponents = (componentsObject, componentMap) => {
    const customComponents = Object.entries(componentsObject.schemas ?? {}).reduce((acc, [key, value]) => {
        if (value instanceof ZodType) {
            return acc;
        }
        if (acc[key]) {
            throw new Error(`Schema "${key}" is already registered`);
        }
        acc[key] = value;
        return acc;
    }, {});
    const components = Array.from(componentMap).reduce((acc, [_zodType, component]) => {
        if (component.type === 'complete') {
            if (acc[component.ref]) {
                throw new Error(`Schema "${component.ref}" is already registered`);
            }
            acc[component.ref] = component.schemaObject;
        }
        return acc;
    }, customComponents);
    return Object.keys(components).length ? components : undefined;
};
const createParamComponents = (componentsObject, componentMap) => {
    const customComponents = Object.entries(componentsObject.parameters ?? {}).reduce((acc, [key, value]) => {
        if (acc[key]) {
            throw new Error(`Parameter "${key}" is already registered`);
        }
        acc[key] = value;
        return acc;
    }, {});
    const components = Array.from(componentMap).reduce((acc, [_zodType, component]) => {
        if (component.type === 'complete') {
            if (acc[component.ref]) {
                throw new Error(`Parameter "${component.ref}" is already registered`);
            }
            acc[component.ref] = component.paramObject;
        }
        return acc;
    }, customComponents);
    return Object.keys(components).length ? components : undefined;
};
const createHeaderComponents = (componentsObject, componentMap) => {
    const customComponents = Object.entries(componentsObject.headers ?? {}).reduce((acc, [key, value]) => {
        if (acc[key]) {
            throw new Error(`Header "${key}" is already registered`);
        }
        acc[key] = value;
        return acc;
    }, {});
    const components = Array.from(componentMap).reduce((acc, [_zodType, component]) => {
        if (component.type === 'complete') {
            if (acc[component.ref]) {
                throw new Error(`Header "${component.ref}" is already registered`);
            }
            acc[component.ref] = component.headerObject;
        }
        return acc;
    }, customComponents);
    return Object.keys(components).length ? components : undefined;
};
const createResponseComponents = (componentMap) => {
    const components = Array.from(componentMap).reduce((acc, [_zodType, component]) => {
        if (component.type === 'complete') {
            if (acc[component.ref]) {
                throw new Error(`Response "${component.ref}" is already registered`);
            }
            acc[component.ref] = component.responseObject;
        }
        return acc;
    }, {});
    return Object.keys(components).length ? components : undefined;
};
const createRequestBodiesComponents = (componentMap) => {
    const components = Array.from(componentMap).reduce((acc, [_zodType, component]) => {
        if (component.type === 'complete') {
            if (acc[component.ref]) {
                throw new Error(`RequestBody "${component.ref}" is already registered`);
            }
            acc[component.ref] =
                component.requestBodyObject;
        }
        return acc;
    }, {});
    return Object.keys(components).length ? components : undefined;
};
//# sourceMappingURL=components.js.map