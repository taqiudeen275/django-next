import { createComponentResponseRef } from './components';
import { createContent } from './content';
import { createSchemaOrRef } from './schema';
import { isISpecificationExtension } from './specificationExtension';
export const createResponseHeaders = (responseHeaders, components) => {
    if (!responseHeaders) {
        return undefined;
    }
    return Object.entries(responseHeaders.shape).reduce((acc, [key, zodSchema]) => {
        acc[key] = createHeaderOrRef(zodSchema, components);
        return acc;
    }, {});
};
export const createHeaderOrRef = (schema, components) => {
    const component = components.headers.get(schema);
    if (component && component.type === 'complete') {
        return {
            $ref: createComponentHeaderRef(component.ref),
        };
    }
    // Optional Objects can return a reference object
    const baseHeader = createBaseHeader(schema, components);
    if ('$ref' in baseHeader) {
        throw new Error('Unexpected Error: received a reference object');
    }
    const ref = schema._def?.openapi?.header?.ref ?? component?.ref;
    if (ref) {
        components.headers.set(schema, {
            type: 'complete',
            headerObject: baseHeader,
            ref,
        });
        return {
            $ref: createComponentHeaderRef(ref),
        };
    }
    return baseHeader;
};
export const createBaseHeader = (schema, components) => {
    const { ref, ...rest } = schema._def.openapi?.header ?? {};
    const schemaOrRef = createSchemaOrRef(schema, {
        components,
        type: 'input',
    });
    const required = !schema.isOptional();
    return {
        ...rest,
        ...(schema && { schema: schemaOrRef }),
        ...(required && { required }),
    };
};
export const createComponentHeaderRef = (ref) => `#/components/headers/${ref}`;
const createHeaders = (headers, responseHeaders, components) => {
    if (!responseHeaders && !headers) {
        return undefined;
    }
    const createdHeaders = createResponseHeaders(responseHeaders, components);
    return {
        ...headers,
        ...createdHeaders,
    };
};
export const createResponse = (responseObject, components) => {
    if ('$ref' in responseObject) {
        return responseObject;
    }
    const component = components.responses.get(responseObject);
    if (component && component.type === 'complete') {
        return { $ref: createComponentResponseRef(component.ref) };
    }
    const { content, headers, responseHeaders, ref, ...rest } = responseObject;
    const maybeHeaders = createHeaders(headers, responseHeaders, components);
    const response = {
        ...rest,
        ...(maybeHeaders && { headers: maybeHeaders }),
        ...(content && { content: createContent(content, components, 'output') }),
    };
    const responseRef = ref ?? component?.ref;
    if (responseRef) {
        components.responses.set(responseObject, {
            responseObject: response,
            ref: responseRef,
            type: 'complete',
        });
        return {
            $ref: createComponentResponseRef(responseRef),
        };
    }
    return response;
};
export const createResponses = (responsesObject, components) => Object.entries(responsesObject).reduce((acc, [path, responseObject]) => {
    if (isISpecificationExtension(path)) {
        acc[path] = responseObject;
        return acc;
    }
    acc[path] = createResponse(responseObject, components);
    return acc;
}, {});
//# sourceMappingURL=responses.js.map