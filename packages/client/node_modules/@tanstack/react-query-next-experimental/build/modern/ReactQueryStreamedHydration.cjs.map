{"version":3,"sources":["../../src/ReactQueryStreamedHydration.tsx"],"sourcesContent":["'use client'\n\nimport {\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate,\n  isServer,\n  useQueryClient,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport { createHydrationStreamProvider } from './HydrationStreamProvider'\nimport type { HydrationStreamProviderProps } from './HydrationStreamProvider'\nimport type {\n  DehydrateOptions,\n  DehydratedState,\n  HydrateOptions,\n  QueryClient,\n} from '@tanstack/react-query'\n\nconst stream = createHydrationStreamProvider<DehydratedState>()\n\n/**\n * This component is responsible for:\n * - hydrating the query client on the server\n * - dehydrating the query client on the server\n */\nexport function ReactQueryStreamedHydration(props: {\n  children: React.ReactNode\n  queryClient?: QueryClient\n  nonce?: string\n  options?: {\n    hydrate?: HydrateOptions\n    dehydrate?: DehydrateOptions\n  }\n  transformer?: HydrationStreamProviderProps<DehydratedState>['transformer']\n}) {\n  const queryClient = useQueryClient(props.queryClient)\n\n  /**\n   * We need to track which queries were added/updated during the render\n   */\n  const [trackedKeys] = React.useState(() => new Set<string>())\n\n  // <server only>\n  if (isServer) {\n    // Do we need to care about unsubscribing? I don't think so to be honest\n    queryClient.getQueryCache().subscribe((event) => {\n      switch (event.type) {\n        case 'added':\n        case 'updated':\n          // console.log('tracking', event.query.queryHash, 'b/c of a', event.type)\n          trackedKeys.add(event.query.queryHash)\n      }\n    })\n  }\n  // </server only>\n\n  return (\n    <stream.Provider\n      // Happens on server:\n      onFlush={() => {\n        /**\n         * Dehydrated state of the client where we only include the queries that were added/updated since the last flush\n         */\n        const shouldDehydrate =\n          props.options?.dehydrate?.shouldDehydrateQuery ??\n          defaultShouldDehydrateQuery\n\n        const dehydratedState = dehydrate(queryClient, {\n          ...props.options?.dehydrate,\n          shouldDehydrateQuery(query) {\n            return trackedKeys.has(query.queryHash) && shouldDehydrate(query)\n          },\n        })\n        trackedKeys.clear()\n\n        if (!dehydratedState.queries.length) {\n          return []\n        }\n\n        return [dehydratedState]\n      }}\n      // Happens in browser:\n      onEntries={(entries) => {\n        for (const hydratedState of entries) {\n          hydrate(queryClient, hydratedState, props.options?.hydrate)\n        }\n      }}\n      // Handle BigInts etc using superjson\n      transformer={props.transformer}\n      nonce={props.nonce}\n    >\n      {props.children}\n    </stream.Provider>\n  )\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,yBAMO;AACP,YAAuB;AACvB,qCAA8C;AAgD1C;AAvCJ,IAAM,aAAS,8DAA+C;AAOvD,SAAS,4BAA4B,OASzC;AACD,QAAM,kBAAc,mCAAe,MAAM,WAAW;AAKpD,QAAM,CAAC,WAAW,IAAU,eAAS,MAAM,oBAAI,IAAY,CAAC;AAG5D,MAAI,6BAAU;AAEZ,gBAAY,cAAc,EAAE,UAAU,CAAC,UAAU;AAC/C,cAAQ,MAAM,MAAM;AAAA,QAClB,KAAK;AAAA,QACL,KAAK;AAEH,sBAAY,IAAI,MAAM,MAAM,SAAS;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AAGA,SACE;AAAA,IAAC,OAAO;AAAA,IAAP;AAAA,MAEC,SAAS,MAAM;AAIb,cAAM,kBACJ,MAAM,SAAS,WAAW,wBAC1B;AAEF,cAAM,sBAAkB,8BAAU,aAAa;AAAA,UAC7C,GAAG,MAAM,SAAS;AAAA,UAClB,qBAAqB,OAAO;AAC1B,mBAAO,YAAY,IAAI,MAAM,SAAS,KAAK,gBAAgB,KAAK;AAAA,UAClE;AAAA,QACF,CAAC;AACD,oBAAY,MAAM;AAElB,YAAI,CAAC,gBAAgB,QAAQ,QAAQ;AACnC,iBAAO,CAAC;AAAA,QACV;AAEA,eAAO,CAAC,eAAe;AAAA,MACzB;AAAA,MAEA,WAAW,CAAC,YAAY;AACtB,mBAAW,iBAAiB,SAAS;AACnC,0CAAQ,aAAa,eAAe,MAAM,SAAS,OAAO;AAAA,QAC5D;AAAA,MACF;AAAA,MAEA,aAAa,MAAM;AAAA,MACnB,OAAO,MAAM;AAAA,MAEZ,gBAAM;AAAA;AAAA,EACT;AAEJ;","names":[]}