{"version":3,"sources":["../../src/HydrationStreamProvider.tsx"],"sourcesContent":["'use client'\n\nimport { isServer } from '@tanstack/react-query'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport * as React from 'react'\nimport { htmlEscapeJsonString } from './htmlescape'\n\nconst serializedSymbol = Symbol('serialized')\n\ninterface DataTransformer {\n  serialize: (object: any) => any\n  deserialize: (object: any) => any\n}\n\ntype Serialized<TData> = unknown & {\n  [serializedSymbol]: TData\n}\n\ninterface TypedDataTransformer<TData> {\n  serialize: (obj: TData) => Serialized<TData>\n  deserialize: (obj: Serialized<TData>) => TData\n}\n\ninterface HydrationStreamContext<TShape> {\n  id: string\n  stream: {\n    /**\n     * **Server method**\n     * Push a new entry to the stream\n     * Will be ignored on the client\n     */\n    push: (...shape: Array<TShape>) => void\n  }\n}\n\nexport interface HydrationStreamProviderProps<TShape> {\n  children: React.ReactNode\n  /**\n   * Optional transformer to serialize/deserialize the data\n   * Example devalue, superjson et al\n   */\n  transformer?: DataTransformer\n  /**\n   * **Client method**\n   * Called in the browser when new entries are received\n   */\n  onEntries: (entries: Array<TShape>) => void\n  /**\n   * **Server method**\n   * onFlush is called on the server when the cache is flushed\n   */\n  onFlush?: () => Array<TShape>\n  /**\n   * A nonce that'll allow the inline script to be executed when Content Security Policy is enforced\n   */\n  nonce?: string\n}\n\nexport function createHydrationStreamProvider<TShape>() {\n  const context = React.createContext<HydrationStreamContext<TShape>>(\n    null as any,\n  )\n  /**\n\n   * 1. (Happens on server): `useServerInsertedHTML()` is called **on the server** whenever a `Suspense`-boundary completes\n   *    - This means that we might have some new entries in the cache that needs to be flushed\n   *    - We pass these to the client by inserting a `<script>`-tag where we do `window[id].push(serializedVersionOfCache)`\n   * 2. (Happens in browser) In `useEffect()`:\n   *   - We check if `window[id]` is set to an array and call `push()` on all the entries which will call `onEntries()` with the new entries\n   *   - We replace `window[id]` with a `push()`-method that will be called whenever new entries are received\n   **/\n  function UseClientHydrationStreamProvider(props: {\n    children: React.ReactNode\n    /**\n     * Optional transformer to serialize/deserialize the data\n     * Example devalue, superjson et al\n     */\n    transformer?: DataTransformer\n    /**\n     * **Client method**\n     * Called in the browser when new entries are received\n     */\n    onEntries: (entries: Array<TShape>) => void\n    /**\n     * **Server method**\n     * onFlush is called on the server when the cache is flushed\n     */\n    onFlush?: () => Array<TShape>\n    /**\n     * A nonce that'll allow the inline script to be executed when Content Security Policy is enforced\n     */\n    nonce?: string\n  }) {\n    // unique id for the cache provider\n    const id = `__RQ${React.useId()}`\n    const idJSON = htmlEscapeJsonString(JSON.stringify(id))\n\n    const [transformer] = React.useState(\n      () =>\n        (props.transformer ?? {\n          // noop\n          serialize: (obj: any) => obj,\n          deserialize: (obj: any) => obj,\n        }) as unknown as TypedDataTransformer<TShape>,\n    )\n\n    // <server stuff>\n    const [stream] = React.useState<Array<TShape>>(() => {\n      if (!isServer) {\n        return {\n          push() {\n            // no-op on the client\n          },\n        } as unknown as Array<TShape>\n      }\n      return []\n    })\n    const count = React.useRef(0)\n    useServerInsertedHTML(() => {\n      // This only happens on the server\n      stream.push(...(props.onFlush?.() ?? []))\n\n      if (!stream.length) {\n        return null\n      }\n      // console.log(`pushing ${stream.length} entries`)\n      const serializedCacheArgs = stream\n        .map((entry) => transformer.serialize(entry))\n        .map((entry) => JSON.stringify(entry))\n        .join(',')\n\n      // Flush stream\n      // eslint-disable-next-line react-hooks/react-compiler\n      stream.length = 0\n\n      const html: Array<string> = [\n        `window[${idJSON}] = window[${idJSON}] || [];`,\n        `window[${idJSON}].push(${htmlEscapeJsonString(serializedCacheArgs)});`,\n      ]\n      return (\n        <script\n          key={count.current++}\n          nonce={props.nonce}\n          dangerouslySetInnerHTML={{\n            __html: html.join(''),\n          }}\n        />\n      )\n    })\n    // </server stuff>\n\n    // <client stuff>\n    // Setup and run the onEntries handler on the client only, but do it during\n    // the initial render so children have access to the data immediately\n    // This is important to avoid the client suspending during the initial render\n    // if the data has not yet been hydrated.\n    if (!isServer) {\n      const win = window as any\n      if (!win[id]?.initialized) {\n        // Client: consume cache:\n        const onEntries = (...serializedEntries: Array<Serialized<TShape>>) => {\n          const entries = serializedEntries.map((serialized) =>\n            transformer.deserialize(serialized),\n          )\n          props.onEntries(entries)\n        }\n\n        const winStream: Array<Serialized<TShape>> = win[id] ?? []\n\n        onEntries(...winStream)\n\n        win[id] = {\n          initialized: true,\n          push: onEntries,\n        }\n      }\n    }\n    // </client stuff>\n\n    return (\n      <context.Provider value={{ stream, id }}>\n        {props.children}\n      </context.Provider>\n    )\n  }\n\n  return {\n    Provider: UseClientHydrationStreamProvider,\n    context,\n  }\n}\n"],"mappings":";;;AAEA,SAAS,gBAAgB;AACzB,SAAS,6BAA6B;AACtC,YAAY,WAAW;AACvB,SAAS,4BAA4B;AAuI7B;AArIR,IAAM,mBAAmB,OAAO,YAAY;AAmDrC,SAAS,gCAAwC;AACtD,QAAM,UAAgB;AAAA,IACpB;AAAA,EACF;AAUA,WAAS,iCAAiC,OAqBvC;AAED,UAAM,KAAK,OAAa,YAAM,CAAC;AAC/B,UAAM,SAAS,qBAAqB,KAAK,UAAU,EAAE,CAAC;AAEtD,UAAM,CAAC,WAAW,IAAU;AAAA,MAC1B,MACG,MAAM,eAAe;AAAA;AAAA,QAEpB,WAAW,CAAC,QAAa;AAAA,QACzB,aAAa,CAAC,QAAa;AAAA,MAC7B;AAAA,IACJ;AAGA,UAAM,CAAC,MAAM,IAAU,eAAwB,MAAM;AACnD,UAAI,CAAC,UAAU;AACb,eAAO;AAAA,UACL,OAAO;AAAA,UAEP;AAAA,QACF;AAAA,MACF;AACA,aAAO,CAAC;AAAA,IACV,CAAC;AACD,UAAM,QAAc,aAAO,CAAC;AAC5B,0BAAsB,MAAM;AAE1B,aAAO,KAAK,GAAI,MAAM,UAAU,KAAK,CAAC,CAAE;AAExC,UAAI,CAAC,OAAO,QAAQ;AAClB,eAAO;AAAA,MACT;AAEA,YAAM,sBAAsB,OACzB,IAAI,CAAC,UAAU,YAAY,UAAU,KAAK,CAAC,EAC3C,IAAI,CAAC,UAAU,KAAK,UAAU,KAAK,CAAC,EACpC,KAAK,GAAG;AAIX,aAAO,SAAS;AAEhB,YAAM,OAAsB;AAAA,QAC1B,UAAU,MAAM,cAAc,MAAM;AAAA,QACpC,UAAU,MAAM,UAAU,qBAAqB,mBAAmB,CAAC;AAAA,MACrE;AACA,aACE;AAAA,QAAC;AAAA;AAAA,UAEC,OAAO,MAAM;AAAA,UACb,yBAAyB;AAAA,YACvB,QAAQ,KAAK,KAAK,EAAE;AAAA,UACtB;AAAA;AAAA,QAJK,MAAM;AAAA,MAKb;AAAA,IAEJ,CAAC;AAQD,QAAI,CAAC,UAAU;AACb,YAAM,MAAM;AACZ,UAAI,CAAC,IAAI,EAAE,GAAG,aAAa;AAEzB,cAAM,YAAY,IAAI,sBAAiD;AACrE,gBAAM,UAAU,kBAAkB;AAAA,YAAI,CAAC,eACrC,YAAY,YAAY,UAAU;AAAA,UACpC;AACA,gBAAM,UAAU,OAAO;AAAA,QACzB;AAEA,cAAM,YAAuC,IAAI,EAAE,KAAK,CAAC;AAEzD,kBAAU,GAAG,SAAS;AAEtB,YAAI,EAAE,IAAI;AAAA,UACR,aAAa;AAAA,UACb,MAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,WACE,oBAAC,QAAQ,UAAR,EAAiB,OAAO,EAAE,QAAQ,GAAG,GACnC,gBAAM,UACT;AAAA,EAEJ;AAEA,SAAO;AAAA,IACL,UAAU;AAAA,IACV;AAAA,EACF;AACF;","names":[]}