"use client";

// src/ReactQueryStreamedHydration.tsx
import {
  defaultShouldDehydrateQuery,
  dehydrate,
  hydrate,
  isServer,
  useQueryClient
} from "@tanstack/react-query";
import * as React from "react";
import { createHydrationStreamProvider } from "./HydrationStreamProvider.js";
import { jsx } from "react/jsx-runtime";
var stream = createHydrationStreamProvider();
function ReactQueryStreamedHydration(props) {
  const queryClient = useQueryClient(props.queryClient);
  const [trackedKeys] = React.useState(() => /* @__PURE__ */ new Set());
  if (isServer) {
    queryClient.getQueryCache().subscribe((event) => {
      switch (event.type) {
        case "added":
        case "updated":
          trackedKeys.add(event.query.queryHash);
      }
    });
  }
  return /* @__PURE__ */ jsx(
    stream.Provider,
    {
      onFlush: () => {
        var _a, _b, _c;
        const shouldDehydrate = ((_b = (_a = props.options) == null ? void 0 : _a.dehydrate) == null ? void 0 : _b.shouldDehydrateQuery) ?? defaultShouldDehydrateQuery;
        const dehydratedState = dehydrate(queryClient, {
          ...(_c = props.options) == null ? void 0 : _c.dehydrate,
          shouldDehydrateQuery(query) {
            return trackedKeys.has(query.queryHash) && shouldDehydrate(query);
          }
        });
        trackedKeys.clear();
        if (!dehydratedState.queries.length) {
          return [];
        }
        return [dehydratedState];
      },
      onEntries: (entries) => {
        var _a;
        for (const hydratedState of entries) {
          hydrate(queryClient, hydratedState, (_a = props.options) == null ? void 0 : _a.hydrate);
        }
      },
      transformer: props.transformer,
      nonce: props.nonce,
      children: props.children
    }
  );
}
export {
  ReactQueryStreamedHydration
};
//# sourceMappingURL=ReactQueryStreamedHydration.js.map