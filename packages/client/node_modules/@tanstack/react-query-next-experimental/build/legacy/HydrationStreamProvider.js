"use client";

// src/HydrationStreamProvider.tsx
import { isServer } from "@tanstack/react-query";
import { useServerInsertedHTML } from "next/navigation";
import * as React from "react";
import { htmlEscapeJsonString } from "./htmlescape.js";
import { jsx } from "react/jsx-runtime";
var serializedSymbol = Symbol("serialized");
function createHydrationStreamProvider() {
  const context = React.createContext(
    null
  );
  function UseClientHydrationStreamProvider(props) {
    var _a;
    const id = `__RQ${React.useId()}`;
    const idJSON = htmlEscapeJsonString(JSON.stringify(id));
    const [transformer] = React.useState(
      () => props.transformer ?? {
        // noop
        serialize: (obj) => obj,
        deserialize: (obj) => obj
      }
    );
    const [stream] = React.useState(() => {
      if (!isServer) {
        return {
          push() {
          }
        };
      }
      return [];
    });
    const count = React.useRef(0);
    useServerInsertedHTML(() => {
      var _a2;
      stream.push(...((_a2 = props.onFlush) == null ? void 0 : _a2.call(props)) ?? []);
      if (!stream.length) {
        return null;
      }
      const serializedCacheArgs = stream.map((entry) => transformer.serialize(entry)).map((entry) => JSON.stringify(entry)).join(",");
      stream.length = 0;
      const html = [
        `window[${idJSON}] = window[${idJSON}] || [];`,
        `window[${idJSON}].push(${htmlEscapeJsonString(serializedCacheArgs)});`
      ];
      return /* @__PURE__ */ jsx(
        "script",
        {
          nonce: props.nonce,
          dangerouslySetInnerHTML: {
            __html: html.join("")
          }
        },
        count.current++
      );
    });
    if (!isServer) {
      const win = window;
      if (!((_a = win[id]) == null ? void 0 : _a.initialized)) {
        const onEntries = (...serializedEntries) => {
          const entries = serializedEntries.map(
            (serialized) => transformer.deserialize(serialized)
          );
          props.onEntries(entries);
        };
        const winStream = win[id] ?? [];
        onEntries(...winStream);
        win[id] = {
          initialized: true,
          push: onEntries
        };
      }
    }
    return /* @__PURE__ */ jsx(context.Provider, { value: { stream, id }, children: props.children });
  }
  return {
    Provider: UseClientHydrationStreamProvider,
    context
  };
}
export {
  createHydrationStreamProvider
};
//# sourceMappingURL=HydrationStreamProvider.js.map